{
  "name": "blog",
  "blog": [
    {
      "id": 2,
      "path" : "web-sensor",
      "title": "Web 传感器技术",
      "des": "<strong>英特尔 SATG Web 团队一直致力于推进和实现 Web 前沿技术以及在 W3C 的标准化。</strong>\n\n今天，传感器数据被用于许多原生应用程序，以实现诸如沉浸式游戏，健身追踪，AR，VR等用例。如果能有一个Web传感器API去缩小原生和Web应用程序之间的差距是不是很酷？Generic Sensor API，就是为Web而诞生的！\n\n什么是Generic Sensor API?<!-- summary -->Generic Sensor API提供了一套接口把传感器设备暴露到Web平台。该API由基础Sensor接口和一组构建于上方的具体传感器类组成。拥有基础接口可以简化具体传感器类的实现和规范流程。比如你可以看一下Gyroscope类，它非常的简短！核心功能由基础Sensor接口提供，Gyroscope类仅用了三个代表角速度的属性扩展它。通常，具体的传感器类代表平台上的实际传感器，例如加速计或陀螺仪。但是，在某些情况下，传感器类的实现会融合来自多个平台传感器的数据，并以便捷的方式向用户展示结果。例如，AbsoluteOrientation传感器基于从加速度计，陀螺仪和磁力计获得的数据提供即用型4x4旋转矩阵。\n\n您可能认为Web平台已经提供了一些传感器数据接口，例如，DeviceMotion和DeviceOrientation事件暴露运动传感器数据，还有一些其他实验性API提供来自环境传感器的数据。那么，为什么我们还需要这个新的API呢？\n\n与现有传感器接口相比，Generic Sensor API有许多优势：<ul><li>Generic Sensor API是一个传感器框架，可以使用新的传感器类轻松扩展，并且每个类都将保留通用接口。为一种传感器类型编写的客户端代码可以重新用于另一种，只需很少的修改！</li><li>您可以配置传感器，例如，设置适合您应用需求的采样频率。</li><li>您可以检测平台上是否有对应传感器。</li><li>传感器读数具有高精度时间戳，可以更好地与应用程序中的其他活动同步。</li><li>传感器数据模型和坐标系统明确定义，允许浏览器供应商实现可互操作的解决方案。</li><li>Generic Sensor 的基础接口没有绑定到DOM（Navigator和Window对象），为将来在Service Workers中使用相同的API或在Headless JS运行时实现Generic Sensor API（例如在嵌入式设备上）开辟了的机会。</li><li>与传统的传感器API相比，安全性和隐私方面是Generic Sensor API的首要任务，并且提供了更好的安全级别。目前已经集成了Permissions API。</li><li>自动的屏幕坐标同步目前可于Accelerometer，Gyroscope，LinearAccelerationSensor，AbsoluteOrientationSensor，RelativeOrientationSensor和Magnetometer。</li></ul>Chrome 支持以下几种传感器。<h3>运动传感器（Motion sensors）</h3><ul><li>加速度计（Accelerometer）</li><li>陀螺仪（Gyroscope）</li><li>线性加速度传感器（LinearAccelerationSensor）</li><li>绝对方向传感器（AbsoluteOrientationSensor）</li><li>相对方向传感器（RelativeOrientationSensor）</li></ul><h3>环境传感器（Environmental sensors）：</h3><ul><li>环境光传感器（AmbientLightSensor）</li><li>磁力计（Magnetometer）</li></ul>您可以通过打开功能标志 chrome://flags/#enable-generic-sensor-extra-classes 来启用环境传感器API以用于开发目的。\n\n如需了解浏览器实现状态的更多信息，请访问 <a href=\"https://chromestatus.com/feature/5298357018820608\">chromestatus.com</a>。<h3>这些传感器是什么？我们如何使用它们？</h3>传感器是一个相当特殊的领域，可能需要简单介绍。如果您熟悉传感器，则可以直接跳到开始编码章节。否则，我们来详细了解每个支持的传感器。<h3>加速度和线性加速度</h3><img src=\"/assets/blog/1/1.gif\" alt=\"测量加速度传感器\">图1: 测量加速度传感器\n\n加速度传感器测量三个轴（X，Y和Z）上承载传感器的设备的加速度。这个传感器是一个惯性传感器，这意味着当设备处于线性自由落体时，总测得的加速度为0m/s2，当一个设备平躺在桌子上时，向上方向（Z轴）的加速度将会等于地球的重力，即g≈+9.8m/s2，因为它测量的是桌子向上推动设备的力。如果将设备推向右侧，则X轴上的加速度为正，如果设备从右侧加速至左侧，则加速度为负。\n\n加速度计可用于如下步骤：步数计算，动作感应或简单的设备定向。通常情况下，加速度计测量结合其他来源的数据，以创建融合传感器，如方向传感器。\n\n线性加速度传感器测量装置传感器的设备的加速度，不包括的重力的作用。例如，当设备处于静止状态时，传感器在三个轴上测量的加速度≈0m/2。<h3>陀螺仪</h3><img src=\"/assets/blog/1/2.gif\" alt=\"测量陀螺仪传感器\">图2: 测量陀螺仪传感器\n\n陀螺仪传感器测量设备在偏转，倾斜时相对于X，Y和Z轴的角速度（rad/s）。大多数消费类设备都有机械（MEMS）陀螺仪，它们是基于惯性科里奥利力来测量旋转速率的惯性传感器。MEMS陀螺仪容易产生漂移，这是由传感器的重力灵敏度引起的，这会使传感器的内部机械系统变形。陀螺仪以相对高的频率振荡，例如10kHz，因此与其他传感器相比可能消耗更多的功率。<h3>方向传感器</h3><img src=\"/assets/blog/1/3.gif\" alt=\"测量绝对方向传感器\">图3: 测量绝对方向传感器\n\n绝对方向传感器是一种的融合传感器，测量设备相对于地球坐标系的旋转，而相对方向传感器则提供设备相对于固定的参考坐标系统的旋转数据。\n\n所有现代3D JavaScript框架均支持四元数和旋转矩阵来表示旋转。但是，如果你直接使用WebGL，方向传感器接口提供了便捷的方法用于WebGL兼容的旋转矩阵。这里有几个代码示例：<code>three.js\n\nlet torusGeometry = new THREE.TorusGeometry(7, 1.6, 4, 3, 6.3);\nlet material = new THREE.MeshBasicMaterial({ color: 0x0071C5 });\nlet torus = new THREE.Mesh(torusGeometry, material);\nscene.add(torus);\n\n// 使用四元数更新网格旋转。\nconst sensorAbs = new AbsoluteOrientationSensor();\nsensorAbs.onreading = () => torus.quaternion.fromArray(sensorAbs.quaternion);\nsensorAbs.start();\n\n//使用旋转矩阵更新网格旋转。\nconst sensorRel = new RelativeOrientationSensor();\nlet rotationMatrix = new Float32Array(16);\nsensor_rel.onreading = () => {\n    <span></span>sensorRel.populateMatrix(rotationMatrix);\n<span></span>torus.matrix.fromArray(rotationMatrix);\n}\nsensorRel.start();</code><code>BABYLON\n\nconst mesh = new BABYLON.Mesh.CreateCylinder(\"mesh\", 0.9, 0.3, 0.6, 9, 1, scene);\nconst sensorRel = new RelativeOrientationSensor({frequency: 30});\nsensorRel.onreading = () => mesh.rotationQuaternion.FromArray(sensorRel.quaternion);\nsensorRel.start();</code><code>WebGL\n\n// 当有新的读数时，初始化传感器和更新模型矩阵。\nlet modMatrix = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);\nconst sensorAbs = new AbsoluteOrientationSensor({frequency: 60});\nsensorAbs.onreading = () => sensorAbs.populateMatrix(modMatrix);\nsensorAbs.start();\n\n// Somewhere in rendering code, update vertex shader attribute for the model\ngl.uniformMatrix4fv(modMatrixAttr, false, modMatrix);</code>方向传感器支持各种用例，如沉浸式游戏，AR和VR。\n\n如果你想了解运动传感器的更多信息，比如高级用例和需求说明等，请参考运动传感器解释文档。<h3>屏幕坐标系同步</h3>默认情况下，空间传感器的读数将在绑定到设备的本地坐标系中解析，并且不考虑屏幕方向。<img src=\"/assets/blog/1/4.png\">图4: 设备坐标系\n\n但是，许多使用案例（如游戏，AR和VR）都需要传感器读数在绑定于屏幕方向的坐标系中解析。<img src=\"/assets/blog/1/5.png\">图5: 屏幕坐标系\n\n以前，传感器读数重新映射到屏幕坐标必须在JavaScript中实现。这种方法效率低下，并且也极大地增加了Web应用程序代码的复杂性：Web应用程序必须监视屏幕方向更改并执行传感器读数的坐标转换，这对欧拉角或四元数来说并不是简单的事情。\n\nGeneric Sensor API提供了更简单可靠的解决方案！本地坐标系对于所有定义的空间传感器类都是可配置的： Accelerometer、Gyroscope、LinearAccelerationSensor、AbsoluteOrientationSensor、RelativeOrientationSensor和Magnetometer。通过将referenceFrame选项传递给传感器对象构造函数，用户可以定义返回的读数是否将在设备或屏幕坐标中解析。<code>// 当有新的读数时，初始化传感器和更新模型矩阵。\n// 或者,可以写成 RelativeOrientationSensor({referenceFrame: \"device\"}).\nconst sensorRelDevice = new RelativeOrientationSensor();\n\n// 传感器读数在屏幕坐标系统中得到解析。不需要手动重新映射！\nconst sensorRelScreen = new RelativeOrientationSensor({referenceFrame: \"screen\"});</code><h3>开始编码!</h3>Generic Sensor API非常容易上手！Sensor接口提供了start()和stop()方法来控制传感器状态和事件处理用于接收传感器状态，错误和新的可用的读数的通知。具体的传感器类通常将其特定的读取属性添加到基类里。<h3>开发环境</h3>在开发过程中，您可以通过localhost去使用Sensor接口，最简单的方法是使用Web Server for Chrome来为您的Web应用程序提供服务。如果您是在移动设备上开发，需要为本地服务器设置端口转发，然后你就可以开始编码了！\n\n当您的代码准备好后，将其部署在支持HTTPS的服务器上。GitHub Pages可以提供HTTPS服务，将是您分享Demo的好地方。<h3>3D模型旋转</h3>在下列简单的例子中，我们使用绝对方向传感器的数据来修改3D模型的旋转四元数。代码中的model是three.js的Object3D类的一个实例，具有quaternion属性。手机定向demo中的以下代码片段解释了绝对定位传感器如何用于旋转3D模型。<code>\nfunction initSensor() {\n    <span></span>sensor = new AbsoluteOrientationSensor({frequency: 60});\n    <span></span>sensor.onreading = () => model.quaternion.fromArray(sensor.quaternion);\n    <span></span>sensor.onerror = event => {\n        <span></span><span></span>if (event.error.name == 'NotReadableError') {\n            <span></span><span></span><span></span>console.log(\"Sensor is not available.\");\n<span></span><span></span>}\n    <span></span>}\n    <span></span>sensor.start();\n}\n</code>设备的方向将反映在model的3D旋转的WebGL场景内。<img src=\"/assets/blog/1/6.png\">图6: 传感器更新3D模型的方向<h3>Punchmeter</h3>下面的代码片段是从punchmeter demo提取出来的，解释了如何使用线性加速度传感器来计算设备在初始化为静止状态的最大速度。<code>this.maxSpeed = 0;\nthis.vx = 0;\nthis.ax = 0;\nthis.t = 0;\n\nfunction onreading() {\n<span></span>let dt = (this.accel.timestamp - this.t) * 0.001; // In seconds.\n<span></span>this.vx += (this.accel.x + this.ax) / 2 * dt;\n\n<span></span>let speed = Math.abs(this.vx);\n\n<span></span>if (this.maxSpeed < speed) {\n<span></span><span></span>this.maxSpeed = speed;\n<span></span>}\n\n<span></span>this.t = this.accel.timestamp;\n<span></span>this.ax = this.accel.x;\n}\n\n....\n\nthis.accel.addEventListener('reading', onreading);</code>当前速度计算为近似加速度函数的积分。<img src=\"/assets/blog/1/7.png\">图7: 测量冲压速度<h3>隐私和安全</h3>传感器读数是敏感数据，可能受到来自恶意网页的各种攻击。Chrome对Generic Sensor API的实现做了一些限制，以减轻潜在的安全和隐私风险。打算使用Generic Sensor API的开发人员必须考虑到这些限制，下面让我们简单地列出它们。<h3>只允许运行在HTTPS</h3>由于Generic Sensor API是一项强大的功能，因此Chrome只允许在安全的情况下使用。实际上，这意味着要使用Generic Sensor API，您需要通过HTTPS访问您的页面。在开发过程中，您可以通过http://localhost进行此操作，但对于最终产品，您需要在服务器上部署HTTPS。<h3>Feature Policy集成</h3>Generic Sensor API集成了Feature Policy用于控制在frame上访问传感器数据。\n\n默认情况下，Sensor对象只允许在主frame或同一个域的子frame内创建，从而防止未经授权的跨域iframe读取传感器数据。您还可以通过明确地启用或禁用相应的策略控制功能来修改此默认行为。\n\n下面的代码片段说明了如何授予加速度计数据访问跨域iframe的权限，这意味着Accelerometer或LinearAccelerationSensor对象可以在跨域iframe里创建。<code>&lt;iframe src=\"https://third-party.com\" allow=\"accelerometer\"/&gt;</code>Note: Feature Policy集成在Chrome 65或更高版本中。在早期版本的Chrome中，Sensor对象只能在主frame内创建。\n\n传感器读数传送可以被暂停\n\n传感器读数只能通过可见网页访问，即用户实际上正在与之交互时。而且，如果用户聚焦到跨域子frame传感器读数传送将会在父页面上被暂停，以防止在跨域子frame中的第三方软件窃取到用户信息。\n\n由于Generic Sensor框架具有很强的可扩展性，我们可以预见更多代表各种传感器类型的新类的出现，并为PWA及Web带来更多功能。\n\n英文作者：Alexander Shalamov, Mikhail Pozdnyakov / 英特尔\n译者：林万铭",
      "date": "2022-08-06",
      "authors": [{
        "author": "林万铭",
        "pos": "软件工程师",
        "com": "英特尔 SATG Web 平台工程",
        "iconid": "wanming",
        "icon": "assets/2022/people/120/wanming.png",
        "icon5": "assets/2022/people/500/wanming.png",
        "bio": ""
        }
      ]  
    },
    {
      "id": 1,
      "path" : "china-pwa-developer-day-2022",
      "title": "第二届中国 PWA 开发者日",
      "des": "第二届中国 PWA 开发者日 (China PWA Developer Day 2022) 即将于 2022 年 8 月 6 日线上举行。欢迎您的参与！",
      "date": "2022-08-06",
      "authors": [{
        "author": "宋青见 (Edwin Song)",
        "pos": "首席产品经理",
        "com": "微软 Edge · 开发者生态 Bio",
        "iconid": "edwin",
        "icon": "assets/2022/people/120/edwin.png",
        "icon5": "assets/2022/people/500/edwin.png",
        "bio": "从业 20 余年，历经软件开发到产品经理，前端应用到云计算之间的风云变幻。曾在英特尔工作了 14 年，主要从事与性能优化、GPU 驱动程序和 Chromium 内核优化相关的软件开发和团队管理。之后，受 Chromium 新架构/创新的启发，有一段短暂的 H5 WebOS 创业经历，2016 年加入微软云计算团队，在 Azure RDS for MySQL 和区块链 PaaS 服务上工作了4年多，作为 Chormium 忠粉，在微软 Edge 浏览器全面采用 Chromium 内核后，加入 Edge PWA 团队，为构建 WebOS 的梦想再出发！"
        },
        {
          "author": "张敏 (Belem Zhang)",
          "pos": "软件技术经理",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "belem",
          "icon": "assets/2022/people/120/belem.png",
          "icon5": "assets/2022/people/500/belem.png",
          "bio": "张敏，参与了 Crosswork、<a href='https://webnn.dev/' target='_blank'>Web Neural Network (WebNN)</a>、渐进式 Web 应用 （PWA）等 Web 项目。 在 2013 年之前，他是 Opera Software 的软件工程经理并领导了客户端运营和关键数据产品团队。 张敏在浏览器产品及质量、网站兼容性、Web API 及应用等方面有多年经验，张敏正和团队努力将英特尔 XPU 的强大功能引入到 Web，并与 Web 社区携手推动 PWA 技术在国内的发展和落地。"
        }
      ]
    }
  ]
}