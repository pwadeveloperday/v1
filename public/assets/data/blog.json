{
  "name": "blog",
  "blog": [
    {
      "id": 3,
      "path": "china-pwa-developer-day-2022",
      "title": "第二届中国 PWA 开发者日",
      "des": "第二届中国 PWA 开发者日 (China PWA Developer Day 2022) 即将于 2022 年 8 月 6 日线上举行。欢迎您的参与！",
      "des2": "",
      "date": "2022-08-06",
      "authors": [
        {
          "author": "宋青见 (Edwin Song)",
          "pos": "首席产品经理",
          "com": "微软 Edge · 开发者生态 Bio",
          "iconid": "edwin",
          "icon": "assets/2022/people/120/edwin.png",
          "icon5": "assets/2022/people/500/edwin.png",
          "bio": "从业 20 余年，历经软件开发到产品经理，前端应用到云计算之间的风云变幻。曾在英特尔工作了 14 年，主要从事与性能优化、GPU 驱动程序和 Chromium 内核优化相关的软件开发和团队管理。之后，受 Chromium 新架构/创新的启发，有一段短暂的 H5 WebOS 创业经历，2016 年加入微软云计算团队，在 Azure RDS for MySQL 和区块链 PaaS 服务上工作了4年多，作为 Chormium 忠粉，在微软 Edge 浏览器全面采用 Chromium 内核后，加入 Edge PWA 团队，为构建 WebOS 的梦想再出发！"
        },
        {
          "author": "张敏 (Belem Zhang)",
          "pos": "软件技术经理",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "belem",
          "icon": "assets/2022/people/120/belem.png",
          "icon5": "assets/2022/people/500/belem.png",
          "bio": "张敏，参与了 Crosswork、<a href='https://webnn.dev/' target='_blank'>Web Neural Network (WebNN)</a>、渐进式 Web 应用 （PWA）等 Web 项目。 在 2013 年之前，他是 Opera Software 的软件工程经理并领导了客户端运营和关键数据产品团队。 张敏在浏览器产品及质量、网站兼容性、Web API 及应用等方面有多年经验，张敏正和团队努力将英特尔 XPU 的强大功能引入到 Web，并与 Web 社区携手推动 PWA 技术在国内的发展和落地。"
        }
      ]
    },
    {
      "id": 2,
      "path": "web-sensor",
      "title": "Web 传感器技术",
      "des": "<strong>英特尔 SATG Web 团队一直致力于推进和实现 Web 前沿技术以及在 W3C 的标准化。</strong>\n\n今天，传感器数据被用于许多原生应用程序，以实现诸如沉浸式游戏，健身追踪，AR，VR等用例。如果能有一个Web传感器API去缩小原生和Web应用程序之间的差距是不是很酷？Generic Sensor API，就是为Web而诞生的！\n\n什么是Generic Sensor API?<!-- summary -->Generic Sensor API提供了一套接口把传感器设备暴露到Web平台。该API由基础Sensor接口和一组构建于上方的具体传感器类组成。拥有基础接口可以简化具体传感器类的实现和规范流程。比如你可以看一下Gyroscope类，它非常的简短！核心功能由基础Sensor接口提供，Gyroscope类仅用了三个代表角速度的属性扩展它。通常，具体的传感器类代表平台上的实际传感器，例如加速计或陀螺仪。但是，在某些情况下，传感器类的实现会融合来自多个平台传感器的数据，并以便捷的方式向用户展示结果。例如，AbsoluteOrientation传感器基于从加速度计，陀螺仪和磁力计获得的数据提供即用型4x4旋转矩阵。\n\n您可能认为Web平台已经提供了一些传感器数据接口，例如，DeviceMotion和DeviceOrientation事件暴露运动传感器数据，还有一些其他实验性API提供来自环境传感器的数据。那么，为什么我们还需要这个新的API呢？\n\n与现有传感器接口相比，Generic Sensor API有许多优势：<ul><li>Generic Sensor API是一个传感器框架，可以使用新的传感器类轻松扩展，并且每个类都将保留通用接口。为一种传感器类型编写的客户端代码可以重新用于另一种，只需很少的修改！</li><li>您可以配置传感器，例如，设置适合您应用需求的采样频率。</li><li>您可以检测平台上是否有对应传感器。</li><li>传感器读数具有高精度时间戳，可以更好地与应用程序中的其他活动同步。</li><li>传感器数据模型和坐标系统明确定义，允许浏览器供应商实现可互操作的解决方案。</li><li>Generic Sensor 的基础接口没有绑定到DOM（Navigator和Window对象），为将来在Service Workers中使用相同的API或在Headless JS运行时实现Generic Sensor API（例如在嵌入式设备上）开辟了的机会。</li><li>与传统的传感器API相比，安全性和隐私方面是Generic Sensor API的首要任务，并且提供了更好的安全级别。目前已经集成了Permissions API。</li><li>自动的屏幕坐标同步目前可于Accelerometer，Gyroscope，LinearAccelerationSensor，AbsoluteOrientationSensor，RelativeOrientationSensor和Magnetometer。</li></ul>Chrome 支持以下几种传感器。<h3>运动传感器（Motion sensors）</h3><ul><li>加速度计（Accelerometer）</li><li>陀螺仪（Gyroscope）</li><li>线性加速度传感器（LinearAccelerationSensor）</li><li>绝对方向传感器（AbsoluteOrientationSensor）</li><li>相对方向传感器（RelativeOrientationSensor）</li></ul><h3>环境传感器（Environmental sensors）：</h3><ul><li>环境光传感器（AmbientLightSensor）</li><li>磁力计（Magnetometer）</li></ul>您可以通过打开功能标志 chrome://flags/#enable-generic-sensor-extra-classes 来启用环境传感器API以用于开发目的。\n\n如需了解浏览器实现状态的更多信息，请访问 <a href=\"https://chromestatus.com/feature/5298357018820608\">chromestatus.com</a>。<h3>这些传感器是什么？我们如何使用它们？</h3>传感器是一个相当特殊的领域，可能需要简单介绍。如果您熟悉传感器，则可以直接跳到开始编码章节。否则，我们来详细了解每个支持的传感器。<h3>加速度和线性加速度</h3><img src=\"/assets/blog/1/1.gif\" alt=\"测量加速度传感器\">图1: 测量加速度传感器\n\n加速度传感器测量三个轴（X，Y和Z）上承载传感器的设备的加速度。这个传感器是一个惯性传感器，这意味着当设备处于线性自由落体时，总测得的加速度为0m/s2，当一个设备平躺在桌子上时，向上方向（Z轴）的加速度将会等于地球的重力，即g≈+9.8m/s2，因为它测量的是桌子向上推动设备的力。如果将设备推向右侧，则X轴上的加速度为正，如果设备从右侧加速至左侧，则加速度为负。\n\n加速度计可用于如下步骤：步数计算，动作感应或简单的设备定向。通常情况下，加速度计测量结合其他来源的数据，以创建融合传感器，如方向传感器。\n\n线性加速度传感器测量装置传感器的设备的加速度，不包括的重力的作用。例如，当设备处于静止状态时，传感器在三个轴上测量的加速度≈0m/2。<h3>陀螺仪</h3><img src=\"/assets/blog/1/2.gif\" alt=\"测量陀螺仪传感器\">图2: 测量陀螺仪传感器\n\n陀螺仪传感器测量设备在偏转，倾斜时相对于X，Y和Z轴的角速度（rad/s）。大多数消费类设备都有机械（MEMS）陀螺仪，它们是基于惯性科里奥利力来测量旋转速率的惯性传感器。MEMS陀螺仪容易产生漂移，这是由传感器的重力灵敏度引起的，这会使传感器的内部机械系统变形。陀螺仪以相对高的频率振荡，例如10kHz，因此与其他传感器相比可能消耗更多的功率。<h3>方向传感器</h3><img src=\"/assets/blog/1/3.gif\" alt=\"测量绝对方向传感器\">图3: 测量绝对方向传感器\n\n绝对方向传感器是一种的融合传感器，测量设备相对于地球坐标系的旋转，而相对方向传感器则提供设备相对于固定的参考坐标系统的旋转数据。\n\n所有现代3D JavaScript框架均支持四元数和旋转矩阵来表示旋转。但是，如果你直接使用WebGL，方向传感器接口提供了便捷的方法用于WebGL兼容的旋转矩阵。这里有几个代码示例：<code>three.js\n\nlet torusGeometry = new THREE.TorusGeometry(7, 1.6, 4, 3, 6.3);\nlet material = new THREE.MeshBasicMaterial({ color: 0x0071C5 });\nlet torus = new THREE.Mesh(torusGeometry, material);\nscene.add(torus);\n\n// 使用四元数更新网格旋转。\nconst sensorAbs = new AbsoluteOrientationSensor();\nsensorAbs.onreading = () => torus.quaternion.fromArray(sensorAbs.quaternion);\nsensorAbs.start();\n\n//使用旋转矩阵更新网格旋转。\nconst sensorRel = new RelativeOrientationSensor();\nlet rotationMatrix = new Float32Array(16);\nsensor_rel.onreading = () => {\n    <span></span>sensorRel.populateMatrix(rotationMatrix);\n<span></span>torus.matrix.fromArray(rotationMatrix);\n}\nsensorRel.start();</code><code>BABYLON\n\nconst mesh = new BABYLON.Mesh.CreateCylinder(\"mesh\", 0.9, 0.3, 0.6, 9, 1, scene);\nconst sensorRel = new RelativeOrientationSensor({frequency: 30});\nsensorRel.onreading = () => mesh.rotationQuaternion.FromArray(sensorRel.quaternion);\nsensorRel.start();</code><code>WebGL\n\n// 当有新的读数时，初始化传感器和更新模型矩阵。\nlet modMatrix = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);\nconst sensorAbs = new AbsoluteOrientationSensor({frequency: 60});\nsensorAbs.onreading = () => sensorAbs.populateMatrix(modMatrix);\nsensorAbs.start();\n\n// Somewhere in rendering code, update vertex shader attribute for the model\ngl.uniformMatrix4fv(modMatrixAttr, false, modMatrix);</code>方向传感器支持各种用例，如沉浸式游戏，AR和VR。\n\n如果你想了解运动传感器的更多信息，比如高级用例和需求说明等，请参考运动传感器解释文档。<h3>屏幕坐标系同步</h3>默认情况下，空间传感器的读数将在绑定到设备的本地坐标系中解析，并且不考虑屏幕方向。<img src=\"/assets/blog/1/4.png\">图4: 设备坐标系\n\n但是，许多使用案例（如游戏，AR和VR）都需要传感器读数在绑定于屏幕方向的坐标系中解析。<img src=\"/assets/blog/1/5.png\">图5: 屏幕坐标系\n\n以前，传感器读数重新映射到屏幕坐标必须在JavaScript中实现。这种方法效率低下，并且也极大地增加了Web应用程序代码的复杂性：Web应用程序必须监视屏幕方向更改并执行传感器读数的坐标转换，这对欧拉角或四元数来说并不是简单的事情。\n\nGeneric Sensor API提供了更简单可靠的解决方案！本地坐标系对于所有定义的空间传感器类都是可配置的： Accelerometer、Gyroscope、LinearAccelerationSensor、AbsoluteOrientationSensor、RelativeOrientationSensor和Magnetometer。通过将referenceFrame选项传递给传感器对象构造函数，用户可以定义返回的读数是否将在设备或屏幕坐标中解析。<code>// 当有新的读数时，初始化传感器和更新模型矩阵。\n// 或者,可以写成 RelativeOrientationSensor({referenceFrame: \"device\"}).\nconst sensorRelDevice = new RelativeOrientationSensor();\n\n// 传感器读数在屏幕坐标系统中得到解析。不需要手动重新映射！\nconst sensorRelScreen = new RelativeOrientationSensor({referenceFrame: \"screen\"});</code><h3>开始编码!</h3>Generic Sensor API非常容易上手！Sensor接口提供了start()和stop()方法来控制传感器状态和事件处理用于接收传感器状态，错误和新的可用的读数的通知。具体的传感器类通常将其特定的读取属性添加到基类里。<h3>开发环境</h3>在开发过程中，您可以通过localhost去使用Sensor接口，最简单的方法是使用Web Server for Chrome来为您的Web应用程序提供服务。如果您是在移动设备上开发，需要为本地服务器设置端口转发，然后你就可以开始编码了！\n\n当您的代码准备好后，将其部署在支持HTTPS的服务器上。GitHub Pages可以提供HTTPS服务，将是您分享Demo的好地方。<h3>3D模型旋转</h3>在下列简单的例子中，我们使用绝对方向传感器的数据来修改3D模型的旋转四元数。代码中的model是three.js的Object3D类的一个实例，具有quaternion属性。手机定向demo中的以下代码片段解释了绝对定位传感器如何用于旋转3D模型。<code>\nfunction initSensor() {\n    <span></span>sensor = new AbsoluteOrientationSensor({frequency: 60});\n    <span></span>sensor.onreading = () => model.quaternion.fromArray(sensor.quaternion);\n    <span></span>sensor.onerror = event => {\n        <span></span><span></span>if (event.error.name == 'NotReadableError') {\n            <span></span><span></span><span></span>console.log(\"Sensor is not available.\");\n<span></span><span></span>}\n    <span></span>}\n    <span></span>sensor.start();\n}\n</code>设备的方向将反映在model的3D旋转的WebGL场景内。<img src=\"/assets/blog/1/6.png\">图6: 传感器更新3D模型的方向<h3>Punchmeter</h3>下面的代码片段是从punchmeter demo提取出来的，解释了如何使用线性加速度传感器来计算设备在初始化为静止状态的最大速度。<code>this.maxSpeed = 0;\nthis.vx = 0;\nthis.ax = 0;\nthis.t = 0;\n\nfunction onreading() {\n<span></span>let dt = (this.accel.timestamp - this.t) * 0.001; // In seconds.\n<span></span>this.vx += (this.accel.x + this.ax) / 2 * dt;\n\n<span></span>let speed = Math.abs(this.vx);\n\n<span></span>if (this.maxSpeed < speed) {\n<span></span><span></span>this.maxSpeed = speed;\n<span></span>}\n\n<span></span>this.t = this.accel.timestamp;\n<span></span>this.ax = this.accel.x;\n}\n\n....\n\nthis.accel.addEventListener('reading', onreading);</code>当前速度计算为近似加速度函数的积分。<img src=\"/assets/blog/1/7.png\">图7: 测量冲压速度<h3>隐私和安全</h3>传感器读数是敏感数据，可能受到来自恶意网页的各种攻击。Chrome对Generic Sensor API的实现做了一些限制，以减轻潜在的安全和隐私风险。打算使用Generic Sensor API的开发人员必须考虑到这些限制，下面让我们简单地列出它们。<h3>只允许运行在HTTPS</h3>由于Generic Sensor API是一项强大的功能，因此Chrome只允许在安全的情况下使用。实际上，这意味着要使用Generic Sensor API，您需要通过HTTPS访问您的页面。在开发过程中，您可以通过http://localhost进行此操作，但对于最终产品，您需要在服务器上部署HTTPS。<h3>Feature Policy集成</h3>Generic Sensor API集成了Feature Policy用于控制在frame上访问传感器数据。\n\n默认情况下，Sensor对象只允许在主frame或同一个域的子frame内创建，从而防止未经授权的跨域iframe读取传感器数据。您还可以通过明确地启用或禁用相应的策略控制功能来修改此默认行为。\n\n下面的代码片段说明了如何授予加速度计数据访问跨域iframe的权限，这意味着Accelerometer或LinearAccelerationSensor对象可以在跨域iframe里创建。<code>&lt;iframe src=\"https://third-party.com\" allow=\"accelerometer\"/&gt;</code>Note: Feature Policy集成在Chrome 65或更高版本中。在早期版本的Chrome中，Sensor对象只能在主frame内创建。\n\n传感器读数传送可以被暂停\n\n传感器读数只能通过可见网页访问，即用户实际上正在与之交互时。而且，如果用户聚焦到跨域子frame传感器读数传送将会在父页面上被暂停，以防止在跨域子frame中的第三方软件窃取到用户信息。\n\n由于Generic Sensor框架具有很强的可扩展性，我们可以预见更多代表各种传感器类型的新类的出现，并为PWA及Web带来更多功能。\n\n英文作者：Alexander Shalamov, Mikhail Pozdnyakov / 英特尔\n译者：林万铭",
      "des2": "",
      "date": "2022-07-06",
      "authors": [
        {
          "author": "林万铭",
          "pos": "软件工程师",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "wanming",
          "icon": "assets/2022/people/120/wanming.png",
          "icon5": "assets/2022/people/500/wanming.png",
          "bio": ""
        }
      ]
    },
    {
      "id": 1,
      "path": "new-era-of-webassembly",
      "title": "WebAssembly，Web 的新时代",
      "des": "<strong>原文刊载于 CSDN《程序员》杂志，2022 年初鲍静及王红娟两位同事基于 WebAssmebly 的最新进展作了更新。</strong>\n\n在浏览器之争中，Chrome 凭借 JavaScript 的卓越性能取得了市场主导地位，然而由于 JavaScript 的无类型特性，导致其运行时消耗大量的性能做为代价，这也是 JavaScript 的瓶颈之一。WebAssembly 旨在解决这一问题。本文从 WebAssembly 的起源到开发实践对其做全面探究，帮助开发者对 WebAssembly 有全面的了解。<!-- summary --><h3>缘起</h3>让我们从浏览器大战说起。Microsoft凭借 Windows捆绑Internet Explorer的先天优势击溃Netscape后，进入了长达数年的静默期。而Netscape则于1998年将Communicator开源，并由Mozilla基金会衍生出Firefox浏览器，在2004年发布了Firefox 1.0版本。从此，第二次浏览器大战拉开帷幕，由Firefox领衔，Safari，Opera等也积极进取，Internet Explorer的主导地位首次受到挑战。2008年Google推出Chrome浏览器，不但逐步侵蚀Firefox的市场，更是压制了老迈的Internet Explorer。在此次大战之后的2012年，StatCounter的数据指出Chrome以微弱优势超越Internet Explorer成为世界上最流行的浏览器。 \n\n分析Google Chrome浏览器战胜Internet Explorer的原因，除了对Web标准更友善的支持外，卓越的性能是其中相当重要的因素，而浏览器性能之争的本质则体现在JavaScript引擎。此前，JavaScript引擎的实现方式经历了遍历语法树到字节码解释器等较为原始的方式，将每条源代码翻译成相应的机器码并执行，并不保存翻译后的机器码，使得解释执行很慢。2008年9月，Google发布了V8 JavaScript引擎。V8被设计用于提高Web浏览器中JavaScript的执行性能，通过及时编译JIT（Just-In-Time）技术，在执行时将JavaScript代码编译成更为高效的机器代码并保存，下次执行同一代码段时无需再编译，使得 JavaScript 获得了几十倍的性能提升。 \n\n然而，JavaScript是个无类型（untyped，变量没有类型）的语言，这直接导致表达式 c = a + b 有多重含义： \n\n<ul><li>a，b均为数字，则算术运算符+表示值相加</li><li>a，b为字符串，则+运算符表示字符串连接</li><li>…</li></ul>表达式执行时JIT 编译器需要检查 a 和 b 的类型，确定操作行为。若a，b均为数字， JIT 编译器则将a，b确认为整型，而一旦某一变量变成字符串，JIT 编译器则不得不将之前编译的机器码推倒重来。由此可见，JavaScript 的无类型特性建立在消耗大量性能代价的基础之上。即便JIT编译器在对变量类型发生变化时已进行相应优化，但仍然有很多情况 JavaScript引擎未进行或者无法优化，例如for-of，try-catch，try-finally，with语句以及复合let，const赋值的函数等。\n\n由此可见，JavaScript的无类型是 JavaScript引擎的性能瓶颈之一，改进方案有两种：一是设计一门新的强类型语言并强制开发者进行类型指定，二是给现有的 JavaScript 加上变量类型。\n\n微软开发的TypeScript属于第一种改进方案。它是扩展了JavaScript特性的语言，包含了类型批注，编译时类型检查，类型推断和擦除等功能，TypeScript开发者在声明变量时指定类型，使得 JavaScript 引擎能够更快的将这种强类型的语言编译成弱类型。\n\n看看第二种方案：\n<code>function add(a, b) { \n  a = a | 0; \n  b = b | 0; \n  return (a + b) | 0; \n}\n</code>这是带有两个参数（a和b）的JavaScript函数，和通常JavaScript代码不同的地方在于a = a | 0 及b = b | 0以及返回值后面均利用标注进行了按位OR操作。这么做的优点是使JavaScript引擎强制转换变量的值为整型执行。通过标注加上变量类型，JavaScript引擎就能更快的编译。\n\n既然增加变量类型能够提升 Web 性能，有没有办法将静态类型代码例如C/C++等转换成JavaScript指令的子集呢？上面的这段代码恰恰是作为JavaScript子集的asm.js，由下面的C编译而来： <code>int add(int a, int b) {\n  return a + b;\n}\n</code>\n事实上，早在1995年起就已经有Netscape Plugin API（NPAPI）在内的可以使用浏览器运行C/C++程序的项目在开发。而2013年问世的asm.js 是目前较为广泛的方案。asm.js是一种中间编程语言，允许用C/C++语言编写的计算机软件作为Web应用程序运行，并保持更好的性能，而Mozilla Firefox从版本22起成为第一个为asm.js 特别优化的网页浏览器。\n\nGoogle也同样在为原生代码运行在 Web 端而努力。Google Native Client（NaCl）采用沙盒技术，让Intel x86、ARM或MIPS子集的机器码直接在沙盒上运行。它能够在无需安装插件的情况下从浏览器直接运行原生可执行代码，使Web应用程序可以用接近于机器码运作的速度来运行。而Google Portable Native Client（PNaCl）则稍有变化，通过一些前端编译器将C/C++源代码编译成LLVM的中间字节码而不是x86或ARM代码，并且进行优化以及链接。\n\n<table><tr><th>方案</th><th>年代</th><th>发起人</th><th>标准</th><th>目标大小</th><th>安全性</th><th>可移植性</th><th>载入时间</th><th>跨浏览器</th><th>性能</th><th>共享内存</th></tr><tr><td>JavaScript</td><td>1995</td><td>Netscape</td><td>ECMA</td><td>-</td><td>是</td><td>是</td><td>快</td><td>是</td><td>慢</td><td>否</td></tr><tr><td>ActiveX</td><td>1996</td><td>Microsoft</td><td>否</td><td>-</td><td>否</td><td>否</td><td>慢</td><td>否</td><td>慢</td><td>是</td></tr><tr><td>asm.js</td><td>2013</td><td>Mozilla</td><td>否</td><td>大</td><td>是</td><td>是</td><td>慢</td><td>一般</td><td>快</td><td>否</td></tr><tr><td>NaCl</td><td>2008</td><td>Google</td><td>否</td><td>小</td><td>是</td><td>一般</td><td>快</td><td>否</td><td>快</td><td>是</td></tr><tr><td>PNaCl</td><td>2013</td><td>Google</td><td>否</td><td>小</td><td>是</td><td>是</td><td>快</td><td>否</td><td>快</td><td>是</td></tr></table>\n\n表1：JavaScript 及原生代码支持对比\n\n有了类型支持，第二种方案性能提升潜力远远大于第一种。\n\n然而，无论是asm.js 或现有PNaCl的解决方案，都面临着一些缺陷（例如1KB的C源码编译生成asm.js后的大小有480KB）或者其他浏览器不支持的窘境，而2016年10月对Chromium问题跟踪代码的评论更是表明，Google Native Client小组已被关闭。\n\n作为Web浏览器性能和代码重用的解决方案，asm.js及PNaCl都没能被普遍接受，那么有没有上述表格中的特性全部占优，且跨厂商的解决方案呢？<h3>新时代</h3>WebAssembly旨在解决这个问题。\n\nWebAssembly（简称Wasm）是一种适合于编译到Web的，新的可移植的，大小和加载时间高效的格式。这是一个新的平台无关的二进制代码格式，目标是解决JavaScript性能的问题。这个新的二进制格式远小于JavaScript，可由浏览器的JavaScript引擎直接加载和执行，这样可节省从JavaScript到字节码，从字节码到执行前的机器码所花费的及时编译JIT（Just-In-Time）时间。 作为一种低级语言，它定义了一个抽象语法树（Abstract Syntax Tree，AST），开发人员可以以文本格式进行调试。\n\nWebAssembly描述了一个内存安全的沙箱执行环境，可以在现有的JavaScript虚拟机中实现。 当嵌入到Web中时，WebAssembly将强制执行浏览器的同源和权限安全策略。因此，和经常出现安全 漏洞的Flash插件相比，WebAssembly是一个更加安全的解决方案。\n\nWebAssembly可由C/C++等语言编译而来。此外，WebAssembly由Google，Mozilla，Microsoft以及Apple牵头的W3C社区组共同努力，基本覆盖主流的浏览器厂商，因此其可移植性相较Silverlight等有极大提升，平台兼容问题将不复出现。\n\n在Web平台的很多项目中，对于原生新功能的支持需要Web浏览器或者Runtime提供复杂的标准化的API来实现，但是JavaScript API往往较慢。使用WebAssembly，这些标准API可以更简单，并且操作在更低的水平。例如，对于一个面部识别的Web项目，对于访问数据流我们可以由简单的JavaScript API实现，而把面部识别原生SDK做的事情交由WebAssembly实现。\n\n需要了解的是，WebAssembly不是将C/C++等其他语言编译到JavaScript，更不是一种新的编程语言。\n\n<h3>探究</h3><h4>wast 文本文件</h4>上文的C语言求和代码经由编译器生成add.wasm, 将add.wasm 代码转换为WebAssembly的文本格式 add.wast（转换工具见本文工具链章节）： \n\n<code>(module\n  (type (;0;) (func (result i32)))\n  (type (;1;) (func))\n  (type (;2;) (func (param i32 i32) (result i32)))\n  (type ...)\n  (func (;0;) (type 1) nop)\n   (func (;1;) (type 2) (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (func ...)\n  (table (;0;) 2 2 funcref)\n  (memory (;0;) 256 256)\n   (global (;0;) (mut i32) (i32.const 5243920))\n  (export \"memory\" (memory 0))\n  (export \"add\" (func 1))\n  (export ...)\n   (elem (;0;) (i32.const 1) func 0)\n)</code>WebAssembly中代码的可装载和可执行单元被称为一个模块（module）。在运行时，一个模块可以被一组 import值实例化，多个模块实例能够访问相同的共享状态。目前文本格式中的module主要用S表达式来表示。\n\nModule主体解读：<ol><li>type：声明函数类型</li><li>func：声明函数</li><li>table：用于存储对象引用，可以实现函数指针的功能</li><li>memory：声明内存</li><li>global：声明全局变量</li><li>import/export：声明导入/导出函数和变量等</li><li>elem：用于初始化table</li></ol>一个单一的逻辑函数定义包含两个部分：功能部分声明在模块中每个内部函数定义的签名，代码段部分包含由功能部分声明的每个函数的函数体。WebAssembly是带有返回值的静态类型，并且所有参数都含有类型。上面的 add.wast 中func (;1;)可以解读为： <ol><li>声明了一个索引为1的函数（export为add） </li><li>包含两个参数，都是32位整型</li><li>结果是一个32位整型</li><li>函数体是一个32位的加法: 上面是得到第一个局部变量的值, 下面是得到第二个局部变量的值</li></ol><h4>二进制 Wasm文件</h4><img src=\"/assets/blog/wasm/p1.png\" alt=\"wasm文件源码\">图1： wasm文件源码\n\n由C语言求和代码经过编译生成二进制文件，通读文件可以找到相应的头部，类型，导入、函数以及代码段等等。通过JavaScript API载入Wasm二进制文件后，最终转换到机器码执行。<h3>工具链</h3>开发人员现在可以使用相应的工具链从C / C ++源文件编译WebAssembly模块。WebAssembly由许多工具支持，以帮助开发人员构建和处理源文件和生成的二进制内容。<h4>Emscripten</h4>Emscripten是其中无法回避的工具之一。\n\n<img src=\"/assets/blog/wasm/p2.png\" alt=\"Emscripten工具链流程图\">图2：Emscripten工具链流程图\n\nEmscripten SDK管理器（emsdk）用于管理多个SDK和工具，并且指定当前正被使用到编译代码的特定SDK和工具集。\n\nEmscripten的主要工具是Emscripten编译器前端（emcc），它是例如gcc的标准编译器的简易替代实现。\n\nEmcc 使用Clang和LLVM将C/C++编译成WebAssembly二进制格式，并生成JavaScript文件为编译后的WebAssembly提供API支持，输出的JavaScript可以由Node.js执行，或者嵌入HTML在浏览器中运行。这带来的直接结果就是，C 和 C++ 程序经过编译后可在 Javascript 上运行，无需任何插件。<h4>WABT 及 Binaryen</h4>除此之外，对于想要使用由其他工具（如Emscripten）生成的WebAssembly二进制文件感兴趣的开发者，目前官方额外提供了另外两组不同的工具： \n\n<ul><li>WABT - WebAssembly二进制工具包</li><li>Binaryen - 编译器和工具链</li></ul>WABT工具包支持将二进制WebAssembly格式转换为可读的文本格式。其中wasm2wat命令行工具可以将WebAssembly二进制文件转换为可读的文本文件。而wat2wasm命令行工具则执行完全相反的过程。\n\nBinaryen则是一套更为全面的工具链，是用C++编写的用于WebAssembly的编译器和工具链基础结构库。它具有 C API 和一套自己的逻辑程序的中间表示(IR)，可以极其轻松快速地编译为 WebAssembly，因为它本质上是 WebAssembly 的一个子集，并可以在 IR 上执行一些优化，支持代码合并等。它旨在使编译WebAssembly容易，快速，有效。\n\n通过 Binaryen，可以进行编译、优化，它提供了一系列工具，可以解释 WebAssembly代码，汇编和反汇编。比如可以使用wasm-opt编译器优化WebAssembly文件更小更快，也可以使用编译器wasm2js将WebAssembly文件编译成JavaScript文件等等。\n\n由此可见，Emscripten提供了完整的C/C++到WebAssembly的解决方案。而WABT和Binaryen则帮助提升了WebAssembly的工具链生态。\n\n由于WebAssembly 正处于活跃开发阶段，各项编译步骤和编译工具会有大幅变更和改进，相信最终的编译工具和步骤会趋于便捷，需要留意官方网站的最新动态。<h3>实战</h3>Linux平台编译原生代码到WebAssembly可由如下步骤实现：<h4>编译环境准备</h4>操作系统必须有可以工作的编译器工具链，因此需要安装gcc、cmake环境，此外Python也是需要的（本文使用了Ubuntu 20.04, 自带Python 3.8）。<code>  $ sudo apt-get update\n  $ sudo apt-get install build-essential cmake\n  $ sudo apt-get install git</code><h4>安装emscripten</h4><code>  $ git clone https://github.com/emscripten-core/emsdk.git\n  $ cd emsdk\n  $ git pull\n  $ ./emsdk install latest\n  $ ./emsdk activate latest\n  $ source ./emsdk_env.sh\n</code><h4>开始编译程序</h4>现在一个完整的工具链已经具备，我们可以使用它来编译简单的程序到WebAssembly。但是，还有一些其他注意事项： 除了Wasm二进制文件和JavaScript wrapper，如果还希望emscripten生成一个可直接运行的程序的HTML页面，则必须指定一个扩展名为.html的输出文件。\n\n在编译之前，首先准备一个最基本的 add.c 程序。<code>  #include <stdio.h>\n  int add(int a, int b)\n  {\n    return a + b;\n  }\n  int main()\n  {\n    printf(\"%d\", add(1, 2));\n  }\n</code>按如下的命令编辑好add.c程序并编译：<code>  $ vim add.c\n  $ emcc add.c -o add.html\n</code>默认情况下，Emscripten 设置 EXIT_RUNTIME=0，这意味着我们不包含关闭运行时的代码，浏览器可能会报如下错误：\n\n<img src=\"/assets/blog/wasm/p3.png\" alt=\"浏览器加载Wasm文件错误\">图3：浏览器加载Wasm文件错误重新编译应用程序，设置EXIT_RUNTIME=1:<code>  $ emcc add.c -s EXIT_RUNTIME=1 -o add.html</code><h4>运行WebAssembly应用</h4>以Chrome浏览器为例，如果直接在浏览器内本地打开HTML文件，会有如下错误：\n\n<img src=\"/assets/blog/wasm/p4.png\" alt=\"XMLHttpRequest本地访问的跨域请求错误\">图4：XMLHttpRequest本地访问的跨域请求错误\n\n由于XMLHttpRequest跨域请求不支持file://协议，必须经由HTTP实际输出，可以由Python3的http.server改进：<code>  $ python3 -m http.server > /dev/null 2>&1 &</code>在浏览器中输入http://127.0.0.1:8000 并打开add.html，就能直接看到转换成WebAssembly的应用程序输出结果。<h4>创建独立WebAssembly</h4>默认情况下，emcc会创建JavaScript文件和WebAssembly的组合，其中JS加载包含编译代码的WebAssembly。 对于C/C++开发人员，他们可能更倾向于创建独立的WebAssembly，用于JavaScript开发人员调用。为了简便，我们使用下面的C 文件的内容进行编译：<code>  int add(int a, int b) {\n    return a + b;\n  }</code>并执行以下编译命令后即可得到独立的Wasm文件：<code>  $ emcc add.c -Os -s STANDALONE_WASM=1 -s EXPORTED_FUNCTIONS=\"['_add']\" -Wl, --no-entry -o add.wasm</code><h4>JavaScript API 调用</h4>从C / C ++程序编译获得一个.wasm模块之后，JavaScript开发人员可以通过如下方式进行载入.wasm文件并执行。<code>  &lt;script&gt;\n  WebAssembly.instantiateStreaming(fetch(\"add.wasm\", {})).then(proj => {\n    console.log(proj.instance.exports.add(1, 2));\n    });\n  &lt;script&gt;</code>最后一行调用导出的WebAssembly函数，最终执行add(1, 2)，并且在控制台获得期望的结果输出。\n\n<img src=\"/assets/blog/wasm/p5.png\" alt=\"WebAssembly 求和函数在控制台的输出\">图5：WebAssembly 求和函数在控制台的输出",
      "des2": "<h3>性能</h3>那么，WebAssembly的真实性能如何呢？我们用一直被用来作为CPU基准测试的斐波那契 （Fibonacci）数列来进行对比，这里使用的是性能较差的递归算法，在Chrome环境下，能够看到WebAssembly性能优势越发明显。<table><tr><th></th><th>JavaScript (ms)</th><th>WebAssembly (ms)</th></tr><tr><td>fibonacci (25) </td><td>0.53</td><td>0.15</td></tr><tr><td>fibonacci (31) </td><td>6.82</td><td>2.91</td></tr><tr><td>fibonacci (37) </td><td>123.13</td><td>52.18</td></tr><tr><td>fibonacci (41) </td><td>830.55</td><td>355.13</td></tr><tr><td>fibonacci (43) </td><td>2201.65</td><td>930.31</td></tr><table>表2：斐波那契 （Fibonacci）数列性能对比\n\n尽管重复测试时结果不尽相同，重启浏览器并多次测试取平均值后依然可以看到WebAssembly的运算量比JavaScript快了近一个量级。<h3>应用</h3>现阶段已经有很多 WebAssembly 的应用，比如AutoCAD Web、Google Earth、Unity 3d、Unreal Engine、eBay等，包括Google Meet也借助WebAssembly实现了视频背景的实时虚化和替代。\n\n<img src=\"/assets/blog/wasm/p6.png\" alt=\"Google Earth\">图6：Google Earth\n\n目前包括Chrome、Safari、Edge、Firefox在内的大多数主流浏览器都已经支持WebAssembly，直接打开浏览器就可以体验WebAssembly的强大性能。<h3>开发者</h3>WebAssembly对于Web有显著的性能提升，对于开发者尤其是前端或者JavaScript开发人员而言，并不意味着WebAssembly将会取代JavaScript。\n\n<img src=\"/assets/blog/wasm/p7.png\" alt=\"WebAssembly 与JavaScript 引擎的关系\">图7：WebAssembly 与JavaScript 引擎的关系\n\nWebAssembly被设计为对JavaScript的补充，而不是替代，是为了提供一种方法来获得应用程序的关键部分接近原生性能。随着时间的推移，虽然WebAssembly将允许多种语言（不仅仅是C/C++）被编译到Web，但是JavaScript的发展势头不会因此被削弱，并且仍然将保持Web的单一动态语言。此外，由于WebAssembly构建在JavaScript引擎的基础架构上，JavaScript和WebAssembly将在许多场景中配合使用。 \n\n那么WebAssembly是不是仅仅面向C/C++开发者呢？答案依旧是否定的。WebAssembly最初实现的重点是C, C++，目前对由Mozilla主导开发的Rust语言的支持也比较成熟，对C#、Go、TypeScript等许多语言的支持也在逐步完善中，相信未来还会继续增加其他语言的支持。<code>  &lt;script&gt;\n    import add from 'add.wasm';\n    console.log(\"1 + 2 = \" + add(1, 2));\n  &lt;/script&gt;</code>在未来，通过ES6模块接口与JavaScript集成，Web开发人员并不需要编写C++，而是可以直接利用其他人编写的库，重用模块化C++库可以像使用JavaScript中的modules一样简单。<h3>进展</h3>2017年，Chrome, Edge, Firefox和Safari一致宣布，已经完成对WebAssembly MVP（最小化可行产品）版本的发布。2019年， WebAssembly 核心规范1.0成为正式的Web标准。\n\n与此同时，社区在确保后向兼容的同时，也在积极探索更多的post-MVP的特性。其中包括：<ul><li>SIMD：SIMD即单指令流多数据流，允许程序并行处理数据块里的多个数据。它使得WebAssembly能充分利用硬件的SIMD指令，极大提升游戏开发、机器学习等应用的性能。2021年7月，WebAssembly SIMD提案进入Phase 5阶段，意味着128位SIMD标准已经趋于完善，并在多种浏览器和工具链中得到支持。社区还在讨论更大宽度的SIMD和更多指令。</li><li>多线程：多线程特性能够充分利用现代多核CPU，同样有助于程序的并行计算能力。目前Chrome、Firefox都支持多线程特性。</li><li>异常处理：许多语言都会用到异常处理，然而WebAssembly目前还没有对异常处理的支持，需要在编译时模拟。目前社区和浏览器正在积极实现这一特性。</li><li>...</li></ul>浏览器之外的WebAssembly也在蓬勃发展，2019年社区宣布了一个名为WASI（WebAssembly系统接口）的项目，用于提供标准化的WebAssembly与不同操作系统之间的交互，专注于安全性和可移植性，引起了业界的广泛兴趣。<h3>社区</h3>包含所有主要浏览器厂商代表的W3C WebAssembly社区组于2015年4月底成立，而相应的工作组于2017年8月成立。目前工作组的任务是，标准化大小和加载时间高效的格式和运行环境，允许编译到Web并在各种实现中行为一致。 2019年12月， W3C宣布WebAssembly 核心规范1.0成为正式的Web标准，为Web带来继 HTML、CSS、JavaScript 之后支持代码在浏览器中运行的第四种语言。\n\n随着WebAssembly在服务端和云端的逐渐应用，2019年底， Mozilla, Fastly, Intel, Red Hat宣布成立字节码联盟Bytecode Alliance，以完善WebAssembly在浏览器之外的生态。字节码联盟致力于建立一个有能力、安全的平台，允许软件开发者和服务提供者在任何基础设施、操作系统或设备上安全运行不受信任的代码，以利用在浏览器世界数十年的相关经验。2021年4月，字节码联盟宣布成为501(c)(6)非营利组织，并新增微软、谷歌和Arm等成员。<h3>展望</h3>目前主要的浏览器厂商对WebAssembly表现积极，均已支持MVP版本，并在努力实现和推进post-MVP的各项特性，以求在Web中高性能需求的应用例如在线游戏、音乐、视频流、AR及VR、平台模拟、虚拟机、远程桌面、压缩及加密等都能够获得接近于原生的性能。相信WebAssembly将会开创Web的新时代。",
      "date": "2022-03-02",
      "authors": [
        {
          "author": "张敏 (Belem Zhang)",
          "pos": "软件技术经理",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "belem",
          "icon": "assets/2022/people/120/belem.png",
          "icon5": "assets/2022/people/500/belem.png",
          "bio": ""
        },
        {
          "author": "包婧",
          "pos": "资深软件工程师",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "wpe",
          "icon": "assets/2022/people/120/wpe.png",
          "icon5": "assets/2022/people/500/wpe.png",
          "bio": ""
        },
        {
          "author": "王红娟",
          "pos": "软件工程师",
          "com": "英特尔 SATG Web 平台工程",
          "iconid": "hongjuan",
          "icon": "assets/2022/people/120/hongjuan.png",
          "icon5": "assets/2022/people/500/hongjuan.png",
          "bio": ""
        }
      ]
    }
  ]
}
